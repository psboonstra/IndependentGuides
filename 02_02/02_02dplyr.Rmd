---
title: "Independent Guide: 2.2 - dplyr"
output: 
  html_document:
  html_notebook:
editor_options: 
  chunk_output_type: inline
---

```{r klippy, echo = FALSE, include = TRUE}
klippy::klippy(position = c("top", "right"), tooltip_message = "Copy")
```

In the second lesson of Week 2, you were introduced to dplyr, which is a package
included in the tidyverse that provides a set of verbs for data wrangling.

To practice using the functions from the dplyr package, open the R project called
`Lessons.Rproj` and a blank R script. Before we can begin, you'll also need to
load the necessary packages into the current R session.

```{r}
library(healthds)
library(tidyverse)
```

## filter()

The `filter` function allows us to include or exclude observations
(i.e., rows) from a dataset based on one or more conditions. The general
structure for using this function follows: `filter(data, condition)`.

Let's consider the `growth_data` from the healthds package. First, we can take a
look at the dataset before any filtering is performed. There are eight
observations across four variables.

```{r}
growth_data
```

If you were interested in the observations for when the infants were three
months old, you would write the following line of code:

```{r}
filter(growth_data, months == 3)
```

Notice the use of two equal signs in the above line of code. In R, two equal
signs is used to denote "is equal to", which is different than using a single
equal sign to set an argument value.

Similarly, you would write the following line of code if you were instead
interested in the observations for when the infants were two months old:

```{r}
filter(growth_data, months == 2)
```

The `filter` function can also be used to specify conditions other than an
equality. For example, we can filter by a two-sided inequality by using != to
denote "is not equal to." Of course, it's possible to filter by one-sided
inequalities as well, which are represented in R as <, <=, >, and >=.

```{r}
filter(growth_data, months != 2)
filter(growth_data, months > 2)
```

We can also filter by multiple conditions using the AND (&) and OR (|)
operators. The AND operator returns the observations where both conditions are
true, and the OR operator returns the observations where at least one condition
is true.

```{r}
filter(growth_data, weight_kg  > 5.0 & height_cm > 50)
filter(growth_data, weight_kg  > 5.0 | height_cm > 50)
```

Remember to save the work you've done. Try saving the script you've been working
in as filter.R for later reference.

## group_by() and summarize()

To practice additional functions from the dplyr package, open another blank
script within the same R project.

The `group_by` function allows us to group data into sub-datasets defined by a
common value. In turn, the `summarize` function provides a summary of the data
based on the grouped data, where a summary statistic is returned for each
sub-dataset. Therefore, the `group_by` function effectively splits the data, and
future actions, such as the `summarize` function, are applied separately to each
sub-dataset. The general structure for using both functions follow:
`group_by(data, variable)` and `summarize(grouped_data, summary_function(variable))`.

For example, if we were interested in assessing the typical weight of infants
using the growth_data, it would make sense to group the observations by month
and obtain the average weight for each month rather than combine all
observations across time into a single average.

First, we would start by grouping the data by month.

```{r}
group_by(growth_data, months)
```

Notice that this returns a grouped data frame that isn't different in appearance
from the original growth_data.

Next, we can wrap this command in a summarize command by specifying the grouped
data frame as the first argument of the `summarize` function. The second
argument will be the desired summary function, which in this case is the mean
of the weight variable.

```{r}
summarize(group_by(growth_data, months), mean(weight_kg))
```

This returns a data frame where the number of rows is equal to the number of
sub-datasets. The first column is defined by the grouping variable and the
second column contains the calculated summary statistics.

However, wrapping commands in this nested manner can make it confusing to
follow the chronology of commands. For this reason, the dplyr package provides
the use of the pipe operator (%>%), which improves the readability of your code.
The pipe operator takes the contents to the left of the operator and passes it
into to the function on the right of the operator, making it easier to
understand the chronology of commands when manipulating data. Returning back to
our example, using the pipe operator returns the same results as the above line
of code.

```{r}
group_by(growth_data, months) %>% summarize(mean(weight_kg))
```

It's even possible to use more than one pipe operator in succession. In this
case, we can instead use the pipe operator to pass the data into the `group_by`
function rather than provide it as the first argument of the function.

```{r}
growth_data %>% group_by(months) %>% summarize(mean(weight_kg))
```

We can also use line breaks after each pipe operator, which will automatically
be indented after the first line to represent the code as a single expression.

```{r}
growth_data %>%
  group_by(months) %>%
  summarize(mean(weight_kg))
```

Try saving these results as an object in your global environment using the
assignment operator.

```{r}
growth_data_weights <-
  growth_data %>%
  group_by(months) %>%
  summarize(mean(weight_kg))
```

Just as before, remember to save the work you've done. Try saving the script
you've been working in as groupby_summarize.R for later reference.
